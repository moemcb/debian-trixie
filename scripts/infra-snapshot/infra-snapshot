#!/usr/bin/env bash
#
#
# Infrastructure Snapshot Tool v2.0
# Captures system state in JSON/Markdown format
#
# Usage: ./infra-snapshot.sh [options]

set -euo pipefail
IFS=$'\n\t'

readonly VERSION="2.0.0"
readonly SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

MODE="json"
OUT="infra-snapshot"
VERBOSE=false

# Colors (disabled if not TTY)
if [[ -t 1 ]]; then
  readonly RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' NC='\033[0m'
else
  readonly RED='' GREEN='' YELLOW='' NC=''
fi

# Utility functions
have() { command -v "$1" >/dev/null 2>&1; }
log_info() { echo -e "${GREEN}✓${NC} $*" >&2; }
log_warn() { echo -e "${YELLOW}⚠${NC} $*" >&2; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }
log_verbose() { [[ "$VERBOSE" == "true" ]] && echo "  $*" >&2 || true; }

usage() {
cat <<'EOF'
Usage: infra-snapshot.sh [options]

Infrastructure snapshot tool - captures system state in JSON or Markdown.

Options:
  --json              Output JSON (default)
  --md                Output Markdown
  --both              Output JSON + Markdown
  --from-json FILE    Convert existing JSON to Markdown
  --validate FILE     Validate JSON
  -o, --output NAME   Output base filename (default: infra-snapshot)
  -v, --verbose       Show detailed progress
  --version           Show version
  -h, --help          Show this help

Examples:
  infra-snapshot.sh --json
  infra-snapshot.sh --both -o my-server
  infra-snapshot.sh --from-json old.json

Dependencies:
  Required: jq, ip, lsblk, ss
  Optional: docker, nft/iptables, fail2ban-client

EOF
}

check_deps() {
  local missing=()
  for cmd in jq ip lsblk ss; do
    have "$cmd" || missing+=("$cmd")
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing required dependencies: ${missing[*]}"
    log_error "Install with: apt install ${missing[*]} (Debian/Ubuntu)"
    exit 1
  fi

  log_verbose "All dependencies found"
}

# Collect system information as JSON
collect_json() {
  log_verbose "Collecting system information..."

  # Use heredoc with command substitution - let jq handle escaping
  cat <<EOF | jq .
{
  "meta": {
    "version": "2.0",
    "generated": "$(date -Iseconds)",
    "host": "$(hostname)"
  },
  "machine": {
    "hostname": "$(hostname)",
    "os": "$(grep '^PRETTY_NAME=' /etc/os-release 2>/dev/null | cut -d= -f2 | tr -d '"' || echo "Unknown")",
    "kernel": "$(uname -r)",
    "uptime": "$(uptime -p 2>/dev/null || echo "unknown")"
  },
  "hardware": {
    "cpu": {
      "model": "$(lscpu | awk -F: '/Model name/ {print $2}' | xargs || echo "Unknown")",
      "cores": $(nproc || echo 1),
      "architecture": "$(uname -m)"
    },
    "memory": {
      "ram_total": "$(free -h | awk '/Mem:/ {print $2}' || echo "Unknown")",
      "swap_total": "$(free -h | awk '/Swap:/ {print $2}' || echo "Unknown")"
    },
    "storage": $(lsblk -J -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT 2>/dev/null | jq -c . || echo '{"blockdevices":[]}'),
    "disk_usage": $(df -h --output=target,size,used,avail,pcent 2>/dev/null | tail -n +2 | \
      awk '{print "{\"mount\":\""$1"\",\"size\":\""$2"\",\"used\":\""$3"\",\"avail\":\""$4"\",\"use_pct\":\""$5"\"}"}' | \
      jq -cs . 2>/dev/null || echo '[]')
  },
  "networking": {
    "interfaces": $(ip -j address 2>/dev/null | jq -c . || echo '[]'),
    "routes": $(ip -j route 2>/dev/null | jq -c . || echo '[]'),
    "listening": $(ss -lntuH 2>/dev/null | \
      awk 'NR>0 {gsub(/"/, "\\\"", $1); gsub(/"/, "\\\"", $5); print "{\"proto\":\""$1"\",\"local\":\""$5"\"}"}' | \
      jq -cs . 2>/dev/null || echo '[]')
  },
  "security": {
    "firewall": "$(if have nft; then echo nftables; elif have iptables; then echo iptables; else echo none; fi)",
    "fail2ban_installed": $(have fail2ban-client && echo true || echo false)
  },
  "containers": {
    "docker": $(if have docker; then docker ps -a --format '{{json .}}' 2>/dev/null | jq -cs . 2>/dev/null; else echo '[]'; fi)
  },
  "automation": {
    "cron_jobs": $(n=$(crontab -l 2>/dev/null | /bin/grep -cvE '^\s*(#|$)' 2>/dev/null) || n=0; echo "$n"),
    "systemd_timers": $(systemctl list-timers --all --no-pager --no-legend 2>/dev/null | wc -l)
  },
  "services": {
    "running": $(systemctl list-units --type=service --state=running --no-pager --no-legend 2>/dev/null | \
      awk '{print $1}' | jq -R . | jq -cs . 2>/dev/null || echo '[]')
  }
}
EOF
}

# Convert JSON to Markdown
json_to_md() {
  local json_file="$1"

  jq -r '
"# Infrastructure Snapshot\n",
"**Generated:** \(.meta.generated)",
"**Host:** \(.meta.host)\n",

"## Machine",
"- **Hostname:** \(.machine.hostname)",
"- **OS:** \(.machine.os)",
"- **Kernel:** \(.machine.kernel)",
"- **Uptime:** \(.machine.uptime)\n",

"## Hardware\n",
"### CPU",
"- **Model:** \(.hardware.cpu.model)",
"- **Cores:** \(.hardware.cpu.cores)",
"- **Architecture:** \(.hardware.cpu.architecture)\n",

"### Memory",
"- **RAM:** \(.hardware.memory.ram_total)",
"- **Swap:** \(.hardware.memory.swap_total)\n",

(if .hardware.disk_usage and (.hardware.disk_usage | length) > 0 then
  "### Disk Usage\n" +
  ([.hardware.disk_usage[] | "- **\(.mount):** \(.used)/\(.size) (\(.use_pct))"] | join("\n")) +
  "\n"
else "" end),

"## Networking\n",
(if .networking.interfaces and (.networking.interfaces | length) > 0 then
  "### Interfaces\n" +
  ([.networking.interfaces[] | "- **\(.ifname):** \(.addr_info[0].local // "no-ip") (\(.operstate // "unknown"))"] | join("\n")) +
  "\n"
else "" end),

(if .networking.listening and (.networking.listening | length) > 0 then
  "### Listening Ports\n" +
  ([.networking.listening[] | "- \(.proto): \(.local)"] | join("\n")) +
  "\n"
else "" end),

"## Security",
"- **Firewall:** \(.security.firewall)",
"- **Fail2ban:** \(if .security.fail2ban_installed then "Installed" else "Not installed" end)\n",

(if .containers.docker and (.containers.docker | length) > 0 then
  "## Containers\n### Docker\n" +
  ([.containers.docker[] | "- **\(.Names)** (\(.State)): \(.Image)"] | join("\n")) +
  "\n"
else "" end),

"## Automation",
"- **Cron jobs:** \(.automation.cron_jobs)",
"- **Systemd timers:** \(.automation.systemd_timers)\n",

(if .services.running and (.services.running | length) > 0 then
  "## Running Services (\(.services.running | length) total)\n" +
  (.services.running[0:20][] | "- \(.)") +
  (if (.services.running | length) > 20 then "\n...and \((.services.running | length) - 20) more" else "" end)
else "" end)
' "$json_file"
}

# Validate JSON
validate_json() {
  local json_file="$1"

  log_verbose "Validating JSON..."

  if ! jq empty "$json_file" 2>/dev/null; then
    log_error "Invalid JSON syntax in $json_file"
    return 1
  fi

  # Check required fields
  local required=(".meta.generated" ".machine.hostname" ".hardware.cpu")
  local missing=()

  for field in "${required[@]}"; do
    jq -e "$field" "$json_file" >/dev/null 2>&1 || missing+=("$field")
  done

  [[ ${#missing[@]} -gt 0 ]] && log_warn "Missing fields: ${missing[*]}"

  log_info "JSON is valid"

  # Show stats
  if [[ "$VERBOSE" == "true" ]]; then
    log_verbose "File size: $(du -h "$json_file" | cut -f1)"
    log_verbose "Interfaces: $(jq '.networking.interfaces | length' "$json_file" 2>/dev/null || echo 0)"
    log_verbose "Services: $(jq '.services.running | length' "$json_file" 2>/dev/null || echo 0)"
    log_verbose "Docker containers: $(jq '.containers.docker | length' "$json_file" 2>/dev/null || echo 0)"
  fi
}

# Main execution
main() {
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) MODE="json" ;;
      --md) MODE="md" ;;
      --both) MODE="both" ;;
      --from-json)
        MODE="fromjson"
        FROMJSON="$2"
        [[ ! -f "$FROMJSON" ]] && { log_error "File not found: $FROMJSON"; exit 1; }
        shift
        ;;
      --validate)
        MODE="validate"
        VALIDATE="$2"
        [[ ! -f "$VALIDATE" ]] && { log_error "File not found: $VALIDATE"; exit 1; }
        shift
        ;;
      -o|--output) OUT="$2"; shift ;;
      -v|--verbose) VERBOSE=true ;;
      --version) echo "$VERSION"; exit 0 ;;
      -h|--help) usage; exit 0 ;;
      *) log_error "Unknown option: $1"; usage; exit 1 ;;
    esac
    shift
  done

  # Temp file for md mode (declared here for trap scope)
  local tmp_json=""
  trap '[[ -n "${tmp_json:-}" && -f "${tmp_json:-}" ]] && rm -f "${tmp_json:-}"' EXIT

  # Execute based on mode
  case "$MODE" in
    json)
      check_deps
      collect_json > "$OUT.json"
      log_info "Written $OUT.json"
      ;;
    md)
      check_deps
      tmp_json="$(mktemp)"
      collect_json > "$tmp_json"
      json_to_md "$tmp_json" > "$OUT.md"
      log_info "Written $OUT.md"
      ;;
    both)
      check_deps
      collect_json > "$OUT.json"
      json_to_md "$OUT.json" > "$OUT.md"
      log_info "Written $OUT.json and $OUT.md"
      ;;
    fromjson)
      json_to_md "$FROMJSON" > "$OUT.md"
      log_info "Converted $FROMJSON → $OUT.md"
      ;;
    validate)
      validate_json "$VALIDATE"
      ;;
  esac
}

main "$@"
